{
  AEORM © 2026 by Akos Eigler is licensed under CC BY 4.0.
  To view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/

  This license requires that reusers give credit to the creator. It allows reusers to distribute, remix, adapt,
  and build upon the material in any medium or format, even for commercial purposes.
}

Unit AE.ORM.Generator;

Interface

Uses AE.ORM.Generator.Settings, ZConnection, System.SysUtils;

Type
  TAEORMEntityGeneratorLogAction = ( eglaGeneratingName, eglaTableDiscovered, eglaFieldDiscovered, eglaPrimaryKeyDiscovered,
    eglaRelationDiscovered, eglaGeneratingFileHeader, eglaGeneratingForwardDeclarations, eglaGeneratingInterfaceSection,
    eglaGeneratingImplementation, eglaGeneratingFileFooter );

  TAEORMEntityGeneratorLogEvent = Procedure(Sender: TObject; Const inLogAction: TAEORMEntityGeneratorLogAction; Const
    inTableName, inFieldName, inRelationName: String) Of Object;

  TAEORMEntityGenerator = Class
  strict private
    _logevent: TAEORMEntityGeneratorLogEvent;
    _settings: TAEORMEntityGeneratorSettings;
    _sqlconnection: TZConnection;
    Procedure AddFileFooter(Const inStringBuilder: TStringBuilder);
    Procedure AddFileHeader(Const inStringBuilder: TStringBuilder; Const inUnitName: String);
    Procedure AddForwardDeclarations(Const inStringBuilder: TStringBuilder);
    Procedure AddImplementation(Const inStringBuilder: TStringBuilder);
    Procedure AddInterfaceDeclarations(Const inStringBuilder: TStringBuilder);
    Procedure GenerateNames;
    Function SanitizePropertyName(Const inPropertyName: String): String;
  strict protected
    Procedure Log(Const inLogAction: TAEORMEntityGeneratorLogAction; Const inTableName, inFieldName, inRelationName: String);
  public
    Constructor Create; ReIntroduce;
    Destructor Destroy; Override;
    Procedure Connect;
    Procedure Disconnect;
    Procedure DiscoverAll;
    Procedure DiscoverFields;
    Procedure DiscoverRelations;
    Procedure DiscoverTables;
    Function Generate(Const inUnitName: String): String;
    Property LogEvent: TAEORMEntityGeneratorLogEvent Read _logevent Write _logevent;
    Property Settings: TAEORMEntityGeneratorSettings Read _settings;
    Property SQLConnection: TZConnection Read _sqlconnection Write _sqlconnection;
  End;

Implementation

Uses ZDbcIntFs, AE.ORM.Generator.Entities;

Const
  FIELDTYPE: Array[TAEORMEntityGeneratorFieldType] Of String = ( 'String', 'Integer', 'Int64', 'UInt64', 'Double', 'Boolean', 'TDateTime' );
  INITIALVALUE: Array[TAEORMEntityGeneratorFieldType] Of String = ( '''''', '0', '0', '0', '0', 'False', '0' );
  ENCODEMETHOD: Array[TAEORMEntityGeneratorFieldType] Of String = ( 'EncodeString', 'EncodeInteger', 'EncodeInteger', 'EncodeUInteger', 'EncodeDouble', 'EncodeBoolean', 'EncodeDateTime' );

Procedure TAEORMEntityGenerator.AddFileFooter(Const inStringBuilder: TStringBuilder);
Begin
  Log(eglaGeneratingFileFooter, '', '', '');

  inStringBuilder.AppendLine;
  inStringBuilder.Append('End.');
End;

Procedure TAEORMEntityGenerator.AddFileHeader(Const inStringBuilder: TStringBuilder; Const inUnitName: String);
Var
  units, s: String;
Begin
  Log(eglaGeneratingFileHeader, '', '', '');

  inStringBuilder.AppendLine('// This file was automatically generated by TAEORMEntityGenerator.');
  inStringBuilder.AppendLine('// Keep in mind that changes to this file might be overwritten and therefore disappear');
  inStringBuilder.AppendLine('// if it is regenerated!!!');
  inStringBuilder.AppendLine('//');
  inStringBuilder.AppendLine('// https://github.com/aehimself/AEFramework');
  inStringBuilder.AppendLine;
  inStringBuilder.AppendLine('Unit ' + inUnitName + ';');
  inStringBuilder.AppendLine;
  inStringBuilder.AppendLine('Interface');
  inStringBuilder.AppendLine;
  inStringBuilder.Append('Uses AE.ORM.Entity, ZDbcIntFs, AE.ORM.Entity.FieldValueList, AE.ORM.DBConnectionPool, AE.ORM.Entity.Collection');

  units := '';

  For s In _settings.InterfaceUnits Do
    units := units + s + ', ';

  If Not units.IsEmpty Then
  Begin
    units := units.Substring(0, units.Length - 2);

    inStringBuilder.Append(', ' + units);
  End;

  inStringBuilder.AppendLine(';');
  inStringBuilder.AppendLine;
  inStringBuilder.AppendLine('Type');
End;

Procedure TAEORMEntityGenerator.AddForwardDeclarations(Const inStringBuilder: TStringBuilder);
Var
  tableenum, relationenum: String;
Begin
  Log(eglaGeneratingForwardDeclarations, '', '', '');

  inStringBuilder.AppendLine('  // Forward declarations to make sure circular recerences will be valid');

  For tableenum In _settings.Tables Do
  Begin
    Log(eglaGeneratingForwardDeclarations, tableenum, '', '');

    inStringBuilder.AppendLine;
    inStringBuilder.AppendLine('  ' + _settings.Table[tableenum].GeneratedClassName + ' = Class;');

    For relationenum In _settings.EntityCollectionRelations(tableenum) Do
    Begin
      Log(eglaGeneratingForwardDeclarations, tableenum, '', relationenum);

      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('  ' + _settings.Relation[relationenum].GeneratedClassName + ' = Class;');
    End;
  End;
End;

Procedure TAEORMEntityGenerator.AddImplementation(Const inStringBuilder: TStringBuilder);
Var
  tableenum, fieldenum, allfields, allpkeys, pkeysql, pkeyencode, relfields, units, s, relationenum: String;
  table: TAEORMEntityGeneratorTable;
  field: TAEORMEntityGeneratorField;
  relation: TAEORMEntityGeneratorRelation;
  a: Integer;
  dummyneeded: Boolean;
Begin
  Log(eglaGeneratingImplementation, '', '', '');

  inStringBuilder.AppendLine;
  inStringBuilder.AppendLine('Implementation');
  inStringBuilder.AppendLine;

  inStringBuilder.Append('Uses AE.ORM.Entity.Helper, ZVariant, System.SysUtils, AE.ORM.Exceptions');

  units := '';

  For s In _settings.ImplementationUnits Do
    units := units + s + ', ';

  If Not units.IsEmpty Then
  Begin
    units := units.Substring(0, units.Length - 2);

    inStringBuilder.Append(', ' + units);
  End;

  inStringBuilder.AppendLine(';');

  For tableenum In _settings.Tables Do
  Begin
    Log(eglaGeneratingImplementation, tableenum, '', '');

    table := _settings.Table[tableenum];

    allfields := '';

    For fieldenum in table.Fields Do
      allfields := allfields + fieldenum + ',';

    If Not allfields.IsEmpty Then
      allfields := allfields.Substring(0, allfields.Length - 1);

    allpkeys := '';
    pkeysql := '';
    pkeyencode := '';

    For fieldenum In table.PrimaryKeys Do
    Begin
      allpkeys := allpkeys + 'in' + fieldenum + ': ' + FIELDTYPE[table.Field[fieldenum].PropertyType] + ', ';

      pkeysql := pkeysql + fieldenum + '=?,';

      pkeyencode := pkeyencode + ENCODEMETHOD[table.Field[fieldenum].VariableType] + '(in' + fieldenum + '), ';
    End;

    If Not allpkeys.IsEmpty Then
      allpkeys := allpkeys.Substring(0, allpkeys.Length - 2);

    If Not pkeysql.IsEmpty Then
      pkeysql := pkeysql.Substring(0, pkeysql.Length - 1);

    If Not pkeyencode.IsEmpty Then
      pkeyencode := pkeyencode.Substring(0, pkeyencode.Length - 2);

    inStringBuilder.AppendLine;
    inStringBuilder.AppendLine('//');
    inStringBuilder.AppendLine('// ' + table.GeneratedClassName);
    inStringBuilder.AppendLine('//');

    If _settings.RelationsExistForTable(tableenum) Then
    Begin
      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('Constructor ' + table.GeneratedClassName + '.Create(Const inConnectionPool: TAEORMDBConnectionPool);');
      inStringBuilder.AppendLine('Begin');
      inStringBuilder.AppendLine('  inherited;');
      inStringBuilder.AppendLine;

      // Single objects which are connected to this one (based on incoming relations)
      For relationenum In _settings.SingleEntityRelations(tableenum) Do
      Begin
        relation := _settings.Relation[relationenum];

        inStringBuilder.AppendLine('  ' + relation.SingleEntityGeneratedVariableName + ' := ' + _settings.Table[relation.SourcetableName].GeneratedClassName + '.Create(inConnectionPool);');
      End;

      // Object collections which are connected to this one (based on outgoing relation)
      For relationenum In _settings.EntityCollectionRelations(tableenum) Do
      Begin
        relation := _settings.Relation[relationenum];

        inStringBuilder.AppendLine('  ' + relation.GeneratedVariableName + ' := ' + relation.GeneratedClassName + '.Create(inConnectionPool);');
        inStringBuilder.AppendLine('  ' + relation.GeneratedVariableName + '.Parent := Self;');
      End;

      inStringBuilder.AppendLine('End;');
      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('Destructor ' + table.GeneratedClassName + '.Destroy;');
      inStringBuilder.AppendLine('Begin');

      // Single objects which are connected to this one (based on incoming relations)
      For relationenum In _settings.SingleEntityRelations(tableenum) Do
      Begin
        relation := _settings.Relation[relationenum];

        inStringBuilder.AppendLine('  FreeAndNil(' + relation.SingleEntityGeneratedVariableName + ');');
      End;

      // Object collections which are connected to this one (based on outgoing relation)
      For relationenum In _settings.EntityCollectionRelations(tableenum) Do
      Begin
        relation := _settings.Relation[relationenum];

        inStringBuilder.AppendLine('  FreeAndNil(' + relation.GeneratedVariableName + ');');
      End;

      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('  inherited;');
      inStringBuilder.AppendLine('End;');
    End;

    inStringBuilder.AppendLine;

    If Not allpkeys.IsEmpty Then
    Begin
      inStringBuilder.AppendLine('Procedure ' + table.GeneratedClassName + '.LoadByID(' + allpkeys + ');');
      inStringBuilder.AppendLine('Begin');
      inStringBuilder.AppendLine('  Self.Load(''' + pkeysql + ''', [' + pkeyencode + ']);');
      inStringBuilder.AppendLine('End;');
      inStringBuilder.AppendLine;
    End;

    inStringBuilder.AppendLine('Procedure ' + table.GeneratedClassName + '.InternalClear;');
    inStringBuilder.AppendLine('Begin');
    inStringBuilder.AppendLine('  inherited;');
    inStringBuilder.AppendLine;

    For relationenum In _settings.EntityCollectionRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      inStringBuilder.AppendLine('  ' + relation.GeneratedVariableName + '.Clear;');
    End;

    For relationenum In _settings.SingleEntityRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      inStringBuilder.AppendLine('  ' + relation.SingleEntityGeneratedVariableName + '.Clear;');
    End;

    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      If Not field.ReadOnly Then
        inStringBuilder.AppendLine('  ' + field.GeneratedOriginalVariableName + ' := ' + INITIALVALUE[field.VariableType] + ';');

      inStringBuilder.AppendLine('  ' + field.GeneratedVariableName + ' := ' + INITIALVALUE[field.VariableType] + ';');

      If Not field.Required Then
        inStringBuilder.AppendLine('  ' + field.GeneratedIsNullVariableName + ' := True;');
    End;

    inStringBuilder.AppendLine('End;');
    inStringBuilder.AppendLine;
    inStringBuilder.AppendLine('Procedure ' + table.GeneratedClassName + '.InternalLoad(Const inResultSet: IZResultSet);');

    dummyneeded := False;

    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      dummyneeded := dummyneeded Or field.Required;
    End;

    If dummyneeded Then
    Begin
      inStringBuilder.AppendLine('Var');
      inStringBuilder.AppendLine('  dummy: Boolean;');
    End;

    inStringBuilder.AppendLine('Begin');
    inStringBuilder.AppendLine('  inherited;');
    inStringBuilder.AppendLine;

    a := 0;

    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      inStringBuilder.Append('  ReadValue(inResultSet, ' + a.ToString + ', ' + field.GeneratedVariableName + ', ');

      If Not field.Required Then
        inStringBuilder.AppendLine(field.GeneratedIsNullVariableName + ');')
      Else
        inStringBuilder.AppendLine('dummy);');

      Inc(a);
    End;

    inStringBuilder.AppendLine;

    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      If Not field.ReadOnly Then
        inStringBuilder.AppendLine('  ' + field.GeneratedOriginalVariableName + ' := ' + field.GeneratedVariableName + ';');
    End;

    inStringBuilder.AppendLine('End;');
    inStringBuilder.AppendLine;
    inStringBuilder.AppendLine('Procedure ' + table.GeneratedClassName + '.InternalGetChangedFieldValues(Const outChangedFieldValues: TAEORMFieldValueList);');
    inStringBuilder.AppendLine('Begin');
    inStringBuilder.AppendLine('  inherited;');

    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      If Not field.ReadOnly Then
      Begin
        inStringBuilder.AppendLine;
        inStringBuilder.AppendLine('  If Self.' + field.GeneratedPropertyName + 'Changed Then');
        inStringBuilder.Append('    outChangedFieldValues.AddField(''' + fieldenum + ''', ' + field.GeneratedVariableName + ', ');

        If Not field.Required Then
          inStringBuilder.AppendLine(field.GeneratedIsNullVariableName + ');')
        Else
          inStringBuilder.AppendLine('False);');
      End;
    End;

    inStringBuilder.AppendLine('End;');
    inStringBuilder.AppendLine;
    inStringBuilder.AppendLine('Procedure ' + table.GeneratedClassName + '.InternalGetPrimaryKeyValues(Const outPrimaryKeyValues: TAEORMFieldValueList);');
    inStringBuilder.AppendLine('Begin');
    inStringBuilder.AppendLine('  inherited;');
    inStringBuilder.AppendLine;
    inStringBuilder.AppendLine('  If Not Self.Loaded Then');
    inStringBuilder.AppendLine('    Exit;');
    inStringBuilder.AppendLine;

    For s In table.PrimaryKeys Do
    Begin
      inStringBuilder.Append('  outPrimaryKeyValues.AddField(''' + s + ''', ' + table.Field[s].GeneratedVariableName + ', ');

      If table.Field[s].Required Then
        inStringBuilder.AppendLine('False);')
      Else
        inStringBuilder.AppendLine(table.Field[s].GeneratedIsNullVariableName + ');');
    End;

    inStringBuilder.AppendLine('End;');

    If Not table.AfterLoadExtraCode.IsEmpty Then
    Begin
      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('Procedure ' + table.GeneratedClassName + '.InternalAfterLoad;');
      inStringBuilder.AppendLine('Begin');
      inStringBuilder.AppendLine(table.AfterLoadExtraCode);
      inStringBuilder.AppendLine('End;');
    End;

    If Not table.BeforeSaveExtraCode.IsEmpty Then
    Begin
      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('Procedure ' + table.GeneratedClassName + '.InternalBeforeSave;');
      inStringBuilder.AppendLine('Begin');
      inStringBuilder.AppendLine(table.BeforeSaveExtraCode);
      inStringBuilder.AppendLine('End;');
    End;

    inStringBuilder.AppendLine;
    inStringBuilder.AppendLine('Class Function ' + table.GeneratedClassName + '.SelectFieldNames: String;');
    inStringBuilder.AppendLine('Begin');
    inStringBuilder.AppendLine('  Result := ''' + allfields + ''';');
    inStringBuilder.AppendLine('End;');
    inStringBuilder.AppendLine;
    inStringBuilder.AppendLine('Class Function ' + table.GeneratedClassName + '.TableName: String;');
    inStringBuilder.AppendLine('Begin');
    inStringBuilder.AppendLine('  Result := ''' + tableenum + ''';');
    inStringBuilder.AppendLine('End;');

    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      If Not field.ReadOnly Then
      Begin
        inStringBuilder.AppendLine;
        inStringBuilder.AppendLine('Function ' + table.GeneratedClassName + '.' + field.GeneratedPropertyName + 'Changed: Boolean;');
        inStringBuilder.AppendLine('Begin');
        inStringBuilder.AppendLine('  Result := ' + field.GeneratedVariableName + ' <> ' + field.GeneratedOriginalVariableName + ';');
        inStringBuilder.AppendLine('End;');
      End;

      If Not field.OriginalGetterExtraCode.IsEmpty Or (field.PropertyType <> field.VariableType) Then
      Begin
        inStringBuilder.AppendLine;
        inStringBuilder.AppendLine('Function ' + table.GeneratedClassName + '.Get' + field.GeneratedOriginalPropertyName + ': ' + FIELDTYPE[field.PropertyType] + ';');
        inStringBuilder.AppendLine('Begin');

        If Not field.OriginalGetterExtraCode.IsEmpty Then
          inStringBuilder.AppendLine(field.OriginalGetterExtraCode);

        inStringBuilder.AppendLine('End;');
      End;
    End;

    // Single objects which are connected to this one (based on incoming relations)
    For relationenum In _settings.EntityCollectionRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      Log(eglaGeneratingImplementation, tableenum, '', relationenum);

      relfields := '';

      For fieldenum In relation.TargetFields Do
        relfields := relfields + fieldenum + '=?,';

      If Not relfields.IsEmpty Then
        relfields := relfields.Substring(0, relfields.Length - 1);

      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('Function ' + table.GeneratedClassName + '.Get' + relation.GeneratedPropertyName + ': ' + relation.GeneratedClassName + ';');
      inStringBuilder.AppendLine('Var');
      inStringBuilder.AppendLine('  params: TZVariantDynArray;');
      inStringBuilder.AppendLine('Begin');
      inStringBuilder.AppendLine('  If Not ' + relation.GeneratedVariableName + '.Loaded Then');
      inStringBuilder.AppendLine('  Begin');
      inStringBuilder.AppendLine('    SetLength(params, ' + Length(relation.TargetFields).ToString + ');');

      For a := Low(relation.TargetFields) To High(relation.TargetFields) Do
      Begin
        inStringBuilder.AppendLine;

        fieldenum := relation.TargetFields[a];

        If Not _settings.Table[relation.TargetTableName].Field[fieldenum].Required Then
        Begin
          inStringBuilder.AppendLine('    If ' + table.Field[relation.SourceFields[a]].GeneratedIsNullVariableName + ' Then');
          inStringBuilder.AppendLine('      params[' + a.ToString + '] := EncodeNull');
          inStringBuilder.AppendLine('    Else');
          inStringBuilder.AppendLine('      params[' + a.ToString + '] := ' + ENCODEMETHOD[table.Field[relation.SourceFields[a]].VariableType] + '(' + table.Field[relation.SourceFields[a]].GeneratedVariableName + ');');
        End
        Else
          inStringBuilder.AppendLine('    params[' + a.ToString + '] := ' + ENCODEMETHOD[table.Field[relation.SourceFields[a]].VariableType] + '(' + table.Field[relation.SourceFields[a]].GeneratedVariableName + ');');
      End;

      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('    ' + relation.GeneratedVariableName + '.Load(''' + relfields + ''', params);');
      inStringBuilder.AppendLine('  End;');
      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('  Result := ' + relation.GeneratedVariableName + ';');
      inStringBuilder.AppendLine('End;');
    End;

    For relationenum In _settings.SingleEntityRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      Log(eglaGeneratingImplementation, tableenum, '', relationenum);

      relfields := '';

      For fieldenum In relation.SourceFields Do
        relfields := relfields + fieldenum + '=?,';

      If Not relfields.IsEmpty Then
        relfields := relfields.Substring(0, relfields.Length - 1);

      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('Function ' + table.GeneratedClassName + '.Get' + relation.SingleEntityGeneratedPropertyName + ': ' + relation.SingleEntityGeneratedClassName + ';');
      inStringBuilder.AppendLine('Var');
      inStringBuilder.AppendLine('  params: TZVariantDynArray;');
      inStringBuilder.AppendLine('Begin');
      inStringBuilder.AppendLine('  If Not ' + relation.SingleEntityGeneratedVariableName + '.Loaded Then');
      inStringBuilder.AppendLine('  Begin');
      inStringBuilder.AppendLine('    SetLength(params, ' + Length(relation.TargetFields).ToString + ');');

      For a := Low(relation.SourceFields) To High(relation.SourceFields) Do
      Begin
        inStringBuilder.AppendLine;

        fieldenum := relation.SourceFields[a];

        If Not table.Field[fieldenum].Required Then
        Begin
          inStringBuilder.AppendLine('    If ' + table.Field[relation.TargetFields[a]].GeneratedIsNullVariableName + ' Then');
          inStringBuilder.AppendLine('      params[' + a.ToString + '] := EncodeNull');
          inStringBuilder.AppendLine('    Else');
          inStringBuilder.AppendLine('      params[' + a.ToString + '] := ' + ENCODEMETHOD[table.Field[relation.TargetFields[a]].VariableType] + '(' + table.Field[relation.TargetFields[a]].GeneratedVariableName + ');');
        End
        Else
          inStringBuilder.AppendLine('    params[' + a.ToString + '] := ' + ENCODEMETHOD[table.Field[relation.TargetFields[a]].VariableType] + '(' + table.Field[relation.TargetFields[a]].GeneratedVariableName + ');');
      End;

      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('    ' + relation.SingleEntityGeneratedVariableName + '.Load(''' + relfields + ''', params);');
      inStringBuilder.AppendLine('  End;');
      inStringBuilder.AppendLine;
      inStringBuilder.AppendLine('  Result := ' + relation.SingleEntityGeneratedVariableName + ';');
      inStringBuilder.AppendLine('End;');
    End;

    For fieldenum In table.Fields Do
    Begin
      Log(eglaGeneratingImplementation, tableenum, fieldenum, '');

      field := table.Field[fieldenum];

      If Not field.Required Or _settings.AnyRelationField(tableenum, fieldenum) Or Not field.SetterExtraCode.IsEmpty Or (field.PropertyType <> field.VariableType) Then
      Begin
        inStringBuilder.AppendLine;
        inStringBuilder.AppendLine('Procedure ' + table.GeneratedClassName + '.Set' + field.GeneratedPropertyName + '(Const in' + field.GeneratedPropertyName + ': ' + FIELDTYPE[field.PropertyType] + ');');
        inStringBuilder.AppendLine('Begin');

        inStringBuilder.AppendLine('  If Self.' + field.GeneratedPropertyName + ' = in' + field.GeneratedPropertyName + ' Then');
        inStringBuilder.AppendLine('    Exit;');
        inStringBuilder.AppendLine;

        If field.PropertyType = field.VariableType Then
          inStringBuilder.AppendLine('  ' + field.GeneratedVariableName + ' := in' + field.GeneratedPropertyName + ';');

        If Not field.SetterExtraCode.IsEmpty Then
          inStringBuilder.AppendLine(field.SetterExtraCode);

        If Not field.Required Then
          inStringBuilder.AppendLine('  ' + field.GeneratedisNullVariableName + ' := False;');

        If _settings.SingleEntityRelationField(tableenum, fieldenum) Then
        Begin
          inStringBuilder.AppendLine;

          For relationenum In _settings.SingleEntityRelations(tableenum) Do
          Begin
            relation := _settings.Relation[relationenum];

            For s In relation.TargetFields Do
              If s = fieldenum Then
                inStringBuilder.AppendLine('  ' + relation.SingleEntityGeneratedVariableName + '.Clear;');
          End;
        End;

        If _settings.EntityCollectionRelationField(tableenum, fieldenum) Then
        Begin
          inStringBuilder.AppendLine;

          For relationenum In _settings.EntityCollectionRelations(tableenum) Do
          Begin
            relation := _settings.Relation[relationenum];

            For s In relation.SourceFields Do
              If s = fieldenum Then
                inStringBuilder.AppendLine('  ' + relation.GeneratedVariableName + '.Clear;');
          End;
        End;

        inStringBuilder.AppendLine('End;');

        If Not field.Required Then
        Begin
          inStringBuilder.AppendLine;
          inStringBuilder.AppendLine('Procedure ' + table.GeneratedClassName + '.Set' + field.GeneratedPropertyName + 'ToNull;');
          inStringBuilder.AppendLine('Begin');
          inStringBuilder.AppendLine('  ' + field.GeneratedVariableName + ' := ' + INITIALVALUE[field.VariableType] + ';');
          inStringBuilder.AppendLine('  ' + field.GeneratedIsNullVariableName + ' := True;');
          inStringBuilder.AppendLine('End;');
        End;

        If Not field.GetterExtraCode.IsEmpty Or (field.PropertyType <> field.VariableType) Then
        Begin
          inStringBuilder.AppendLine;
          inStringBuilder.AppendLine('Function ' + table.GeneratedClassName + '.Get' + field.GeneratedPropertyName + ': ' + FIELDTYPE[field.PropertyType] + ';');
          inStringBuilder.AppendLine('Begin');

          If field.PropertyType = field.VariableType Then
            inStringBuilder.AppendLine('  Result := ' + field.GeneratedVariableName + ';');

          If Not field.GetterExtraCode.IsEmpty Then
            inStringBuilder.AppendLine(field.GetterExtraCode);

          inStringBuilder.AppendLine('End;');
        End;
      End;
    End;
  End;

  For tableenum In _settings.Tables Do
  Begin
    table := _settings.Table[tableenum];

    s := '';

    For relationenum In _settings.EntityCollectionRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      If s <> relation.GeneratedClassName Then
      Begin
        Log(eglaGeneratingImplementation, tableenum, '', relationenum);

        inStringBuilder.AppendLine;
        inStringBuilder.AppendLine('//');
        inStringBuilder.AppendLine('// ' + relation.GeneratedClassName);
        inStringBuilder.AppendLine('//');
        inStringBuilder.AppendLine;
        inStringBuilder.AppendLine('Procedure ' + relation.GeneratedClassName + '.InternalBeforeSave;');
        inStringBuilder.AppendLine('Var');
        inStringBuilder.AppendLine('  item: ' + _settings.Table[relation.TargetTableName].GeneratedClassName + ';');
        inStringBuilder.AppendLine('Begin');
        inStringBuilder.AppendLine('  inherited;');
        inStringBuilder.AppendLine;
        inStringBuilder.AppendLine('  For item In Self Do');
        inStringBuilder.AppendLine('    If Not item.Loaded Then');
        inStringBuilder.AppendLine('    Begin');

        For a := Low(relation.TargetFields) To High(relation.TargetFields) Do
          inStringBuilder.AppendLine('      item.' + _settings.Table[relation.TargetTableName].Field[relation.Targetfields[a]].GeneratedPropertyName + ' := ' + _settings.GlobalVariablePrefix + 'parent.' + table.Field[relation.SourceFields[a]].GeneratedPropertyName + ';');

        inStringBuilder.AppendLine('    End;');
        inStringBuilder.AppendLine('End;');

        s := relation.GeneratedClassName;
      End;
    End;
  End;
End;

Procedure TAEORMEntityGenerator.AddInterfaceDeclarations(Const inStringBuilder: TStringBuilder);
Var
  tableenum, fieldenum, allpkeys, tmp, relationenum: String;
  table: TAEORMEntityGeneratorTable;
  field: TAEORMEntityGeneratorField;
  relation: TAEORMEntityGeneratorRelation;
Begin
  Log(eglaGeneratingInterfaceSection, '', '', '');

  inStringBuilder.AppendLine;
  inStringBuilder.AppendLine('  // Real interface definitions');

  For tableenum In _settings.Tables Do
  Begin
    Log(eglaGeneratingInterfaceSection, tableenum, '', '');

    table := _settings.Table[tableenum];

    allpkeys := '';

    For fieldenum In table.PrimaryKeys Do
      allpkeys := allpkeys + 'in' + fieldenum + ': ' + FIELDTYPE[table.Field[fieldenum].PropertyType] + ', ';

    If Not allpkeys.IsEmpty Then
      allpkeys := allpkeys.Substring(0, allpkeys.Length - 2);

    inStringBuilder.AppendLine;
    inStringBuilder.AppendLine('  ' + table.GeneratedClassName + ' = Class(TAEORMEntity)');
    inStringBuilder.AppendLine('  strict private');

    // Single objects which are connected to this one (based on incoming relations)
    For relationenum In _settings.SingleEntityRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      inStringBuilder.AppendLine('    ' + relation.SingleEntityGeneratedVariableName + ': ' + _settings.Table[relation.SourcetableName].GeneratedClassName + ';');
    End;

    // Object collections which are connected to this one (based on outgoing relation)
    For relationenum In _settings.EntityCollectionRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      inStringBuilder.AppendLine('    ' + relation.GeneratedVariableName + ': ' + relation.GeneratedClassName + ';');
    End;

    // Variables for holding field data
    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      If Not field.ReadOnly Then
        inStringBuilder.AppendLine('    ' + field.GeneratedOriginalVariableName + ': ' + FIELDTYPE[field.VariableType] + ';');

      inStringBuilder.AppendLine('    ' + field.GeneratedVariableName + ': ' + FIELDTYPE[field.VariableType] + ';');

      If Not field.Required Then
        inStringBuilder.AppendLine('    ' + field.GeneratedIsNullVariableName + ': Boolean;');
    End;

    // Getter methods for single objects which are connected to this one (based on incoming relations)
    For relationenum In _settings.SingleEntityRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      inStringBuilder.AppendLine('    Function Get' + relation.SingleEntityGeneratedPropertyName + ': ' + relation.SingleEntityGeneratedClassName + ';');
    End;

    // Getter methods for object collections which are connected to this one (based on outgoing relation)
    For relationenum In _settings.EntityCollectionRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      inStringBuilder.AppendLine('    Function Get' + relation.GeneratedPropertyName + ': ' + relation.GeneratedClassName + ';');
    End;

    // Setter methods for fields which can be null OR which are used for object connections (based on incoming relations)
    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      If Not field.Required Or _settings.AnyRelationField(tableenum, fieldenum) Or Not field.SetterExtraCode.IsEmpty Then
        inStringBuilder.AppendLine('    Procedure Set' + field.GeneratedPropertyName + '(Const in' + field.GeneratedPropertyName + ': ' + FIELDTYPE[field.PropertyType] + ');');

      If Not field.GetterExtraCode.IsEmpty Or (field.PropertyType <> field.VariableType) Then
        inStringBuilder.AppendLine('    Function Get' + field.GeneratedPropertyName + ': ' + FIELDTYPE[field.PropertyType] + ';');

      If Not field.OriginalGetterExtraCode.IsEmpty Or (field.PropertyType <> field.VariableType) Then
        inStringBuilder.AppendLine('    Function Get' + field.GeneratedOriginalPropertyName + ': ' + FIELDTYPE[field.PropertyType] + ';');
    End;

    inStringBuilder.AppendLine('  strict protected');

    If Not table.AfterLoadExtraCode.IsEmpty Then
      inStringBuilder.AppendLine('    Procedure InternalAfterLoad; Override;');

    If Not table.BeforeSaveExtraCode.IsEmpty Then
      inStringBuilder.AppendLine('    Procedure InternalBeforeSave; Override;');

    inStringBuilder.AppendLine('    Procedure InternalClear; Override;');
    inStringBuilder.AppendLine('    Procedure InternalGetChangedFieldValues(Const outChangedFieldValues: TAEORMFieldValueList); Override;');
    inStringBuilder.AppendLine('    Procedure InternalGetPrimaryKeyValues(Const outPrimaryKeyValues: TAEORMFieldValueList); Override;');
    inStringBuilder.AppendLine('    Procedure InternalLoad(Const inResultSet: IZResultSet); Override;');
    inStringBuilder.AppendLine('  public');
    inStringBuilder.AppendLine('    Class Function TableName: String; Override;');
    inStringBuilder.AppendLine('    Class Function SelectFieldNames: String; Override;');

    If _settings.TableHasAnyRelations(tableenum) Then
    Begin
      inStringBuilder.AppendLine('    Constructor Create(Const inConnectionPool: TAEORMDBConnectionPool); Override;');
      inStringBuilder.AppendLine('    Destructor Destroy; Override;');
    End;

    If Not allpkeys.IsEmpty Then
      inStringBuilder.AppendLine('    Procedure LoadByID(' + allpkeys + ');');

    // Procedures to clear field values
    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      If Not field.Required Then
        inStringBuilder.AppendLine('    Procedure Set' + field.GeneratedPropertyName + 'ToNull;');
    End;

    // Functions to see if a field value has changed
    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      inStringBuilder.AppendLine('    Function ' + field.GeneratedPropertyName + 'Changed: Boolean;');
    End;

    // Single objects which are connected to this one (based on outgoing relations)
    For relationenum In _settings.SingleEntityRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      inStringBuilder.AppendLine('    Property ' + relation.SingleEntityGeneratedPropertyName + ': ' + _settings.Table[relation.SourceTableName].GeneratedClassName + ' Read Get' + relation.SingleEntityGeneratedPropertyName + ';');
    End;

    // Object collections which are connected to this one (based on outgoing relation)
    For relationenum In _settings.EntityCollectionRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      inStringBuilder.AppendLine('    Property ' + relation.GeneratedPropertyName + ': ' + relation.GeneratedClassName + ' Read Get' + relation.GeneratedPropertyName + ';');
    End;

    // Field properties
    For fieldenum In table.Fields Do
    Begin
      field := table.Field[fieldenum];

      If Not field.ReadOnly Then
      Begin
        inStringBuilder.Append('    Property ' + field.GeneratedOriginalPropertyName + ': ' + FIELDTYPE[field.PropertyType] + ' Read ');

        If Not field.OriginalGetterExtraCode.IsEmpty Or (field.PropertyType <> field.VariableType) Then
          inStringBuilder.AppendLine('Get' + field.GeneratedOriginalPropertyName + ';')
        Else
          inStringBuilder.AppendLine(field.GeneratedOriginalVariableName + ';')
      End;

      inStringBuilder.Append('    Property ' + field.GeneratedPropertyName + ': ' + FIELDTYPE[field.PropertyType] + ' Read ');

      If Not field.GetterExtraCode.IsEmpty Or (field.PropertyType <> field.VariableType) Then
        inStringBuilder.Append('Get' + field.GeneratedPropertyName)
      Else
        inStringBuilder.Append(field.GeneratedVariableName);

      inStringBuilder.Append(' Write ');

      If Not field.Required Or _settings.AnyRelationField(tableenum, fieldenum) Or (field.PropertyType <> field.VariableType) Then
        inStringBuilder.AppendLine('Set' + field.GeneratedPropertyName + ';')
      Else
        inStringBuilder.AppendLine(field.GeneratedVariableName + ';');

      If Not field.Required Then
        inStringBuilder.AppendLine('    Property ' + field.GeneratedIsNullPropertyName + ': Boolean Read ' + field.GeneratedIsNullVariableName + ';');
    End;

    inStringBuilder.AppendLine('  End;');
  End;

  For tableenum In _settings.Tables Do
  Begin
    table := _settings.Table[tableenum];

    tmp := '';

    For relationenum In _settings.EntityCollectionRelations(tableenum) Do
    Begin
      relation := _settings.Relation[relationenum];

      If tmp <> relation.GeneratedClassName Then
      Begin
        Log(eglaGeneratingInterfaceSection, tableenum, '', relationenum);

        inStringBuilder.AppendLine;
        inStringBuilder.AppendLine('  ' + relation.GeneratedClassName + ' = Class(TAEORMEntityCollection<' + _settings.Table[relation.TargetTableName].GeneratedClassName + '>)');
        inStringBuilder.AppendLine('  strict private');
        inStringBuilder.AppendLine('    ' + _settings.GlobalVariablePrefix + 'parent: ' + table.GeneratedClassName + ';');
        inStringBuilder.AppendLine('  strict protected');
        inStringBuilder.AppendLine('    Procedure InternalBeforeSave; Override;');
        inStringBuilder.AppendLine('  public');
        inStringBuilder.AppendLine('    Property Parent: ' + table.GeneratedClassName + ' Read ' + _settings.GlobalVariablePrefix + 'parent Write ' + _settings.GlobalVariablePrefix + 'parent;');
        inStringBuilder.AppendLine('  End;');

        tmp := relation.GeneratedClassName;
      End;
    End;
  End;
End;

procedure TAEORMEntityGenerator.Connect;
begin
  Self.Disconnect;

  _sqlconnection.Connect;
end;

Constructor TAEORMEntityGenerator.Create;
Begin
  inherited;

  _settings := TAEORMEntityGeneratorSettings.Create;
End;

Destructor TAEORMEntityGenerator.Destroy;
Begin
  FreeAndNil(_settings);

  inherited;
End;

Procedure TAEORMEntityGenerator.Disconnect;
Begin
  _sqlconnection.Disconnect;
End;

Procedure TAEORMEntityGenerator.DiscoverAll;
Begin
  Self.DiscoverTables;
  Self.DiscoverFields;
  Self.DiscoverRelations;
End;

Procedure TAEORMEntityGenerator.DiscoverFields;
Var
  table, fname: String;
  metadata: IZDatabaseMetadata;
  resultset: IZResultSet;
  field: TAEORMEntityGeneratorField;
  ftype: TAEORMEntityGeneratorFieldType;
Begin
  metadata := _sqlconnection.DbcConnection.GetMetadata;

  For table In _settings.Tables Do
  Begin
    // Catalog = Self.SQLConnection.Database
    // Schema = Self.SQLConnection.Catalog
    resultset := metadata.GetColumns(_sqlconnection.Database, _sqlconnection.Catalog, table, '');

    While resultset.Next Do
    Begin
      fname := resultset.GetString(3); // COLUMN_NAME

      Case TZSQLType(resultset.GetInt(4)) Of // DATA_TYPE
        stString, stUnicodeString:
          ftype := oftString;
        stBoolean:
          ftype := oftBoolean;
        stByte, stShort, stWord, stSmall, stInteger:
          ftype := oftInteger;
        stLongWord, stLong:
          ftype := oftInt64;
        stULong:
          ftype := oftUInt64;
        stFloat, stDouble, stCurrency, stBigDecimal:
          ftype := oftReal;
        stDate, stTime, stTimestamp:
          ftype := oftDateTime;
        Else
        Begin
          // Data type is unsupported, remove the field from detected ones
          _settings.Table[table].Field[fname] := nil;

          Continue;
        End;
      End;

      field := _settings.Table[table].Field[fname];

      field.ReadOnly := resultset.GetBoolean(23); // READONLY
      field.Required := resultset.GetBoolean(10); // NULLABLE
      field.PropertyType := ftype;
      field.VariableType := ftype;

      Log(eglaFieldDiscovered, table, fname, '');
    End;

    // Catalog = Self.SQLConnection.Database
    // Schema = Self.SQLConnection.Catalog
    resultset := metadata.GetPrimaryKeys(_sqlconnection.Database, _sqlconnection.Catalog, table);

    While resultset.Next Do
    Begin
      _settings.Table[table].Field[resultset.GetString(3)].PrimaryKey := True; // COLUMN_NAME

      Log(eglaPrimaryKeyDiscovered, table, resultset.GetString(3), '');
    End;
  End;
End;

Procedure TAEORMEntityGenerator.DiscoverRelations;
Var
  tableenum, sourcefield, targetfield, fieldenum: String;
  table: TAEORMEntityGeneratorTable;
  metadata: IZDatabaseMetadata;
  resultset: IZResultSet;
Begin
  metadata := _sqlconnection.DbcConnection.GetMetadata;

  For tableenum In _settings.Tables Do
  Begin
    table := _settings.Table[tableenum];

    // Catalog = Self.SQLConnection.Database
    // Schema = Self.SQLConnection.Catalog
    resultset := metadata.GetImportedKeys(_sqlconnection.Database, _sqlconnection.Catalog, tableenum);

    While resultset.Next Do
      // We are only interested in relations where the connected table is also in our discovery
      If _settings.ContainsTable(resultset.GetString(2)) Then // PKTABLE_NAME
      Begin
        sourcefield := resultset.GetString(3); // PKCOLUMN_NAME
        targetfield := resultset.GetString(7); // FKCOLUMN_NAME

        If Not table.ContainsField(targetfield) Then
        Begin
          targetfield := '';

          For fieldenum In table.Fields Do
            If fieldenum.ToLower = resultset.GetString(7) Then
            Begin
              targetfield := fieldenum;

              Break;
            End;

          If targetfield.IsEmpty Then
            Continue;
        End;

        If Not _settings.Table[resultset.GetString(2)].ContainsField(sourcefield) Then
        Begin
          sourcefield := '';

          For fieldenum In _settings.Table[resultset.GetString(2)].Fields Do
            If fieldenum.ToLower = resultset.GetString(3).ToLower Then
            Begin
              sourcefield := fieldenum;

              Break;
            End;

          If sourcefield.IsEmpty Then
            Continue;
        End;

        _settings.AddRelation(
          resultset.GetString(11), // inRelationName, FK_NAME
          resultset.GetString(2), // inSourceTableName, PKTABLE_NAME
          sourcefield, // inSourceFieldName
          resultset.GetString(6), // inTargetTableName, FKTABLE_NAME
          targetfield // inTargetFieldName
        );

        Log(eglaRelationDiscovered, '', '', resultset.GetString(11)); // FK_NAME
      End;

    // Catalog = Self.SQLConnection.Database
    // Schema = Self.SQLConnection.Catalog
    resultset := metadata.GetExportedKeys(_sqlconnection.Database, _sqlconnection.Catalog, tableenum);

    While resultset.Next Do
      // We are only interested in relations where the connected table is also in our discovery
      If _settings.ContainsTable(resultset.GetString(6)) Then // FKTABLE_NAME
      Begin
        sourcefield := resultset.GetString(3); // PKCOLUMN_NAME
        targetfield := resultset.GetString(7); // FKCOLUMN_NAME

        If Not table.ContainsField(sourcefield) Then
        Begin
          sourcefield := '';

          For fieldenum In table.Fields Do
            If fieldenum.ToLower = resultset.GetString(3).ToLower Then
            Begin
              sourcefield := fieldenum;

              Break;
            End;

          If sourcefield.IsEmpty Then
            Continue;
        End;

        If Not _settings.Table[resultset.GetString(2)].ContainsField(targetfield) Then
        Begin
          targetfield := '';

          For fieldenum In _settings.Table[resultset.GetString(2)].Fields Do
            If fieldenum.ToLower = resultset.GetString(7).ToLower Then
            Begin
              targetfield := fieldenum;

              Break;
            End;

          If targetfield.IsEmpty Then
            Continue;
        End;

        _settings.AddRelation(
          resultset.GetString(11), // inRelationName, FK_NAME
          resultset.GetString(2), // inSourceTableName, PKTABLE_NAME
          sourcefield, // inSourceFieldName
          resultset.GetString(6), // inTargetTableName, FKTABLE_NAME
          targetfield // inTargetFieldName
        );

        Log(eglaRelationDiscovered, '', '', resultset.GetString(11)); // FK_NAME
      End;
  End;
End;

Procedure TAEORMEntityGenerator.DiscoverTables;
Var
  table: String;
  metadata: IZDatabaseMetadata;
  resultset: IZResultSet;
Begin
  metadata := _sqlconnection.DbcConnection.GetMetadata;

  // Catalog = Self.SQLConnection.Database
  // Schema = Self.SQLConnection.Catalog
  resultset := metadata.GetTables(_sqlconnection.Database, _sqlconnection.Catalog, '', []);

  While resultset.Next Do
  Begin
    table := resultset.GetString(2); // TABLE_NAME

    _settings.Table[table];

    Log(eglaTableDiscovered, table, '', '');
  End;
End;

Function TAEORMEntityGenerator.Generate(Const inUnitName: String): String;
Var
  sb: TStringBuilder;
Begin
  Self.GenerateNames;

  sb := TStringBuilder.Create;
  Try
    Self.AddFileHeader(sb, inUnitName);

    Self.AddForwardDeclarations(sb);

    Self.AddInterfaceDeclarations(sb);

    Self.AddImplementation(sb);

    Self.AddFileFooter(sb);

    Result := sb.ToString;
  Finally
    FreeAndNil(sb);
  End;
End;

Procedure TAEORMEntityGenerator.GenerateNames;
Var
  tableenum, fieldenum, relationenum: String;
  relation: TAEORMEntityGeneratorRelation;
  table: TAEORMEntityGeneratorTable;
  field: TAEORMEntityGeneratorField;
Begin
  For tableenum In _settings.Tables Do
  Begin
    Log(eglaGeneratingName, tableenum, '', '');

    table := _settings.Table[tableenum];

    If table.GeneratedPropertyName.IsEmpty Then
      table.GeneratedPropertyName := SanitizePropertyName(tableenum);

    If table.GeneratedClassName.IsEmpty Then
      table.GeneratedClassName := 'T' + table.GeneratedPropertyName;

    If table.GeneratedVariableName.IsEmpty Then
      table.GeneratedVariableName := _settings.GlobalVariablePrefix + table.GeneratedPropertyName;

    For fieldenum In _settings.Table[tableenum].Fields Do
    Begin
      Log(eglaGeneratingName, tableenum, fieldenum, '');

      field := table.Field[fieldenum];

      If field.GeneratedPropertyName.IsEmpty Then
        field.GeneratedPropertyName := SanitizePropertyName(fieldenum);

      If field.GeneratedVariableName.IsEmpty Then
      Begin
        field.GeneratedVariableName := _settings.GlobalVariablePrefix + field.GeneratedPropertyName;

        If _settings.LowerCaseVariables Then
          field.GeneratedVariableName := field.GeneratedVariableName.ToLower;
      End;

      If field.GeneratedIsNullPropertyName.IsEmpty Then
        field.GeneratedIsNullPropertyName := field.GeneratedPropertyName + 'IsNull';

      If field.GeneratedIsNullVariableName.IsEmpty Then
      Begin
        field.GeneratedIsNullVariableName := _settings.GlobalVariablePrefix + field.GeneratedIsNullPropertyName;

        If settings.LowerCaseVariables Then
          field.GeneratedIsNullVariableName := field.GeneratedIsNullVariableName.ToLower;
      End;

      If field.GeneratedOriginalPropertyName.IsEmpty Then
        field.GeneratedOriginalPropertyName := 'Original' + field.GeneratedPropertyName;

      If field.GeneratedOriginalVariableName.IsEmpty Then
      Begin
        field.GeneratedOriginalVariableName := _settings.GlobalVariablePrefix + field.GeneratedOriginalPropertyName;

        If _settings.LowerCaseVariables Then
          field.GeneratedOriginalVariableName := field.GeneratedOriginalVariableName.ToLower;
      End;
    End;
  End;

  For relationenum In _settings.Relations Do
  Begin
    relation := _settings.Relation[relationenum];

    Log(eglaGeneratingName, '', '', relationenum);

    If relation.GeneratedPropertyName.IsEmpty Then
      relation.GeneratedPropertyName := SanitizePropertyName(_settings.Table[relation.TargetTableName].GeneratedClassName.Substring(1) + 's');

    If relation.GeneratedClassName.IsEmpty Then
      relation.GeneratedClassName := 'T' + _settings.Table[relation.SourceTableName].GeneratedClassName.Substring(1) + '_' + _settings.Table[relation.TargetTableName].GeneratedClassName.Substring(1);

    relation.GeneratedVariableName := _settings.GlobalVariablePrefix + relation.GeneratedPropertyName;

    If relation.SingleEntityGeneratedPropertyName.IsEmpty Then
      relation.SingleEntityGeneratedPropertyName := SanitizePropertyName(_settings.Table[relation.SourceTableName].GeneratedClassName.Substring(1));

    If relation.SingleEntityGeneratedClassName.IsEmpty Then
      relation.SingleEntityGeneratedClassName := _settings.Table[relation.SourceTableName].GeneratedClassName;

    If relation.SingleEntityGeneratedVariableName.IsEmpty Then
      relation.SingleEntityGeneratedVariableName := _settings.GlobalVariablePrefix + relation.SingleEntityGeneratedPropertyName;

    If _settings.LowerCaseVariables Then
    Begin
      relation.GeneratedVariableName := relation.GeneratedVariableName.ToLower;
      relation.SingleEntityGeneratedVariableName := relation.SingleEntityGeneratedVariableName.ToLower;
    End;
  End;
End;

Procedure TAEORMEntityGenerator.Log(Const inLogAction: TAEORMEntityGeneratorLogAction; Const inTableName, inFieldName, inRelationName: String);
Begin
  If Assigned(_logevent) Then
    _logevent(Self, inLogAction, inTableName, inFieldName, inRelationName);
End;

Function TAEORMEntityGenerator.SanitizePropertyName(Const inPropertyName: String): String;
Const
  ACCEPTEDCHARS = ['a'..'z', 'A'..'Z', '0'..'9', '-', '_'];
Var
  c: Char;
Begin
  Result := '';

  For c In inPropertyName Do
    If CharinSet(c, ACCEPTEDCHARS) Then
      Result := Result + c;
End;

End.
